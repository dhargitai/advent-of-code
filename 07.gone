package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"
	// "slices"
	// "strings"
)

/*

Ötlet:
annyi, ahány splitter van, mínusz azok, amikre igaz az, hogy
- van felette az oszlopában splitter, és
- a szomszédos oszlopaiban ő és a felette levő splitter közötti sorokban nincs splitter

mert ezekre igaz az, hogy nem jut sugár

esetleg egy map-ba kigyűjteni őket:
- kulcsai az oszlopok
- értéke egy []int tömb, az adott oszlopon belüli sor koordinátákkal csökkenő sorrendben

aztán minden map elemet végignézni, és ahol a tömb többelemű, ott
for i = 0..utolsó előtti elemig
	megnézni a szomszédos map kulcsokat, és ha léteznek, akkor végignézni a tömbjüket
	hogy van-e bennük olyan elem, ami az i. és i+1-edik elem közé esik
	ha nincs, akkor ezt az elemet nem számoljuk az összes splitbe

	ha map key 0, akkor csak az 1-es keyt vizsgáljuk
	ha map key len(columns) akkor csak a len(columns)-1-et

*/

func main() {
	file := "07.input.txt"
	if len(os.Args) > 1 {
		file = os.Args[1]
	}

	data, err := os.ReadFile(file)
	if err != nil {
		fmt.Println("Error reading file: ", err)
		return
	}

	/*
		oszloponként végigmegyünk
		ha splittert talalunk, gyűjtjük
		ha többedik splittert találunk, akkor azt megjelöljük, hogy az majd vizsgálandó lesz, és eltárolhatjuk hozzá már rögtön az előző és a jelenlegi közötti indexeket, hogy azok között tudjunk majd keresni, plusz hogy hányadik oszlopban van
		aztán majd ezeket kell csak végigiterálni, és ha igaz rá a feltétel, akkor kivonni őket az össz splitter számból
	*/

	// splitterRegex := regexp.MustCompile(`\^`)
	// fmt.Printf("Number of splits: %v\n", len(splitterRegex.FindAll(data, -1))-1)
	lines := strings.Split(strings.TrimSpace(string(data)), "\n")

	var table [][]string
	for _, lineString := range lines {
		line := strings.Split(lineString, "")
		table = append(table, line)
	}

	// allSplits := 0
	splitterRegex := regexp.MustCompile(`\^`)
	splitterRegexLocation := splitterRegex.FindAllString(string(data), -1)
	allSplits := len(splitterRegexLocation)

	rows := len(table)
	columns := len(table[0])

	for j := 0; j < columns; j++ {
		previousSplitterIndex := -1
		currentSplitterIndex := -1

		for i := 0; i < rows; i++ {

			if table[i][j] == "^" {

				if previousSplitterIndex > -1 {

					currentSplitterIndex = i

					noSplitterBetween := true
					for rowBetween := previousSplitterIndex + 1; rowBetween < currentSplitterIndex-1; rowBetween++ {
						if table[rowBetween][j-1] == "^" || table[rowBetween][j+1] == "^" {
							noSplitterBetween = false
						}
					}

					if noSplitterBetween {
						allSplits--
					}

					previousSplitterIndex = i

				} else if previousSplitterIndex == -1 {
					previousSplitterIndex = i
				}

			}

		}
	}

	// start := regexp.MustCompile(`S`)
	// startLocation := start.FindStringIndex(lines[0])

	fmt.Println("All splits: ", allSplits)

}
